'''
Created on 8.7.2014

@author: Morzeux
'''

import itertools

def generate_triangle(max_num):
    """ Generates triangle number. """
    num = 1
    while num <= max_num:
        yield int(num * (num + 1) / 2)
        num += 1

def generate_square(max_num):
    """ Generates square number. """
    num = 1
    while num <= max_num:
        yield num**2
        num += 1

def generate_pentagonal(max_num):
    """ Generates pentagonal number. """
    num = 1
    while num <= max_num:
        yield int(num * (3 * num - 1) / 2)
        num += 1

def generate_hexagonal(max_num):
    """ Generates hexagonal number. """
    num = 1
    while num <= max_num:
        yield int(num * (2 * num - 1))
        num += 1

def generate_heptagonal(max_num):
    """ Generates heptagonal number. """
    num = 1
    while num <= max_num:
        yield int(num * (5 * num - 3) / 2)
        num += 1

def generate_octagonal(max_num):
    """ Generates octagonal number. """
    num = 1
    while num <= max_num:
        yield int(num * (3 * num - 2))
        num += 1

def generate_ranged_digit(func, digit):
    """ Generates numbers in specified digit range. """

    results = []
    min_number = 10**(digit - 1)
    max_number = 10**digit
    gen_func = func(float("inf"))
    while not results or int(results[-1]) < max_number:
        value = next(gen_func)
        if value >= min_number:
            results.append(str(value))
    return set(results[:-1])

def evaluate(value1, value2):
    """ Evaluates two number if they are chainable. """
    return value1[2:] == value2[:2] and value1 != value2

def unique_filter(solution, values, cycle):
    """ Filters chains which are valid for second property. """
    new_solution = []
    for value in solution:
        insides = []
        for i, row in enumerate(values):
            if value in row:
                insides.append(i + 3)
        new_solution.append(insides)

    combine = list(itertools.chain(*tuple([item for item in new_solution])))

    if len(set(combine)) >= cycle:
        for i, item in enumerate(new_solution):
            if len(item) == 1:
                for item2 in new_solution[i + 1:]:
                    if len(item2) == 1 and item[0] == item2[0]:
                        return False
        return True
    else:
        return False

def filter_out_duplicates(values):
    """ Remove chains that are duplicated. """

    new_values = []
    while values:
        new_values.append(values.pop(0))
        if new_values[-1]:
            temp_item = sorted(new_values[-1])
            for j, item2 in enumerate(values):
                if item2:
                    if temp_item == sorted(item2):
                        values[j] = None
    return [item for item in new_values if item]

def problem(digit=4, cycle=6):
    """
    Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
    are all figurate (polygonal) numbers and are generated by the following
    formulae:

        Triangle       P_3,n = n(n+1)/2       1, 3, 6, 10, 15, ...
        Square         P_4,n = n^2            1, 4, 9, 16, 25, ...
        Pentagonal     P_5,n = n(3n-1)/2      1, 5, 12, 22, 35, ...
        Hexagonal      P_6,n = n(2n-1)        1, 6, 15, 28, 45, ...
        Heptagonal     P_7,n = n(5n-3)/2      1, 7, 18, 34, 55, ...
        Octagonal      P_8,n = n(3n-2)        1, 8, 21, 40, 65, ...

    The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
    interesting properties.

        1. The set is cyclic, in that the last two digits of each number is the
           first two digits of the next number (including the last number with
           the first).
        2. Each polygonal type: triangle (P_3,127 = 8128), square
           (P_4,91 = 8281), and pentagonal (P_5,44 = 2882), is represented
           by a different number in the set.
        3. This is the only set of 4-digit numbers with this property.

    Find the sum of the only ordered set of six cyclic 4-digit numbers for
    which each polygonal type: triangle, square, pentagonal, hexagonal,
    heptagonal, and octagonal, is represented by a different number in the set.
    """
    values = [generate_ranged_digit(generate_triangle, digit),
              generate_ranged_digit(generate_square, digit),
              generate_ranged_digit(generate_pentagonal, digit),
              generate_ranged_digit(generate_hexagonal, digit),
              generate_ranged_digit(generate_heptagonal, digit),
              generate_ranged_digit(generate_octagonal, digit)]

    new_values = list(set(list(itertools.chain(*[row for row in values]))))
    solutions = [[val] for val in new_values]
    for _ in range(cycle - 1):
        new_solutions = []
        for sol in solutions:
            for value in new_values:
                if value not in sol and evaluate(sol[-1], value):
                    new_solutions.append(sol + [value])
        solutions = new_solutions

    solutions = [sol for sol in solutions if evaluate(sol[-1], sol[0])]
    solutions = [sol for sol in solutions if unique_filter(sol, values, cycle)]
    solutions = filter_out_duplicates(solutions)
    return sum([int(val) for val in solutions.pop(0)])
